
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>mapping.py &#8212; Streamlines  documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="plot.py" href="plot.html" />
    <link rel="prev" title="analysis.py" href="analysis.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-streamlines.mapping">
<span id="mapping-py"></span><h1><code class="docutils literal notranslate"><span class="pre">mapping.py</span></code><a class="headerlink" href="#module-streamlines.mapping" title="Permalink to this headline">¶</a></h1>
<hr class="docutils" />
<p>Module for mapping channels, channel heads, subcatchment segmentation,
hillslope length (HSL), and filtered topographic aspect, and for analyzing azimuthal
variations.</p>
<hr class="docutils" />
<dl class="docutils">
<dt>Requires Python packages/modules:</dt>
<dd><ul class="first last simple">
<li><a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/index.html#module-pandas" title="(in pandas v0.23.4)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pandas</span></code></a></li>
<li><a class="reference external" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing" title="(in scikit-learn v0.16.dev0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sklearn.preprocessing</span></code></a></li>
<li><a class="reference external" href="http://scikit-image.org/docs/stable/api/skimage.morphology.html#module-skimage.morphology" title="(in skimage v0.14.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.morphology</span></code></a></li>
<li><a class="reference external" href="http://scikit-image.org/docs/stable/api/skimage.filters.html#module-skimage.filters" title="(in skimage v0.14.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skimage.filters</span></code></a></li>
<li><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/ndimage.html#module-scipy.ndimage" title="(in SciPy v1.1.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.ndimage</span></code></a></li>
<li><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/stats.html#module-scipy.stats" title="(in SciPy v1.1.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.stats</span></code></a></li>
<li><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#module-scipy.interpolate" title="(in SciPy v1.1.0)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.interpolate</span></code></a></li>
<li><a class="reference external" href="https://pythonhosted.org/scikit-fmm/index.html#module-skfmm" title="(in scikit-fmm v0.0.9)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">skfmm</span></code></a></li>
</ul>
</dd>
<dt>Imports <code class="docutils literal notranslate"><span class="pre">slm</span></code> modules:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="connect.html#module-streamlines.connect" title="streamlines.connect"><code class="xref py py-mod docutils literal notranslate"><span class="pre">connect</span></code></a></li>
<li><a class="reference internal" href="channelheads.html#module-streamlines.channelheads" title="streamlines.channelheads"><code class="xref py py-mod docutils literal notranslate"><span class="pre">channelheads</span></code></a></li>
<li><a class="reference internal" href="countlink.html#module-streamlines.countlink" title="streamlines.countlink"><code class="xref py py-mod docutils literal notranslate"><span class="pre">countlink</span></code></a></li>
<li><a class="reference internal" href="label.html#module-streamlines.label" title="streamlines.label"><code class="xref py py-mod docutils literal notranslate"><span class="pre">label</span></code></a></li>
<li><a class="reference internal" href="segment.html#module-streamlines.segment" title="streamlines.segment"><code class="xref py py-mod docutils literal notranslate"><span class="pre">segment</span></code></a></li>
<li><a class="reference internal" href="hillslopes.html#module-streamlines.hillslopes" title="streamlines.hillslopes"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hillslopes</span></code></a></li>
<li><a class="reference internal" href="lengths.html#module-streamlines.lengths" title="streamlines.lengths"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lengths</span></code></a></li>
</ul>
</dd>
</dl>
<p>Imports the <a class="reference internal" href="core.html#streamlines.core.Core" title="streamlines.core.Core"><code class="xref py py-class docutils literal notranslate"><span class="pre">Core</span></code></a> class.</p>
<dl class="docutils">
<dt>Imports classes &amp; functions from:</dt>
<dd><ul class="first last simple">
<li><a class="reference internal" href="useful.html#module-streamlines.useful" title="streamlines.useful"><code class="xref py py-mod docutils literal notranslate"><span class="pre">useful</span></code></a></li>
<li><a class="reference internal" href="pocl.html#module-streamlines.pocl" title="streamlines.pocl"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pocl</span></code></a></li>
</ul>
</dd>
</dl>
<hr class="docutils" />
<dl class="class">
<dt id="streamlines.mapping.Mapping">
<em class="property">class </em><code class="descclassname">streamlines.mapping.</code><code class="descname">Mapping</code><span class="sig-paren">(</span><em>state</em>, <em>imported_parameters</em>, <em>geodata</em>, <em>preprocess</em>, <em>trace</em>, <em>analysis</em><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Class providing methods to map and characterize hillslope length (HSL)
across a DTM.</p>
<p>These methods do the bulk of the hard work in mapping hillslope length,
in linking to topographic aspect, and in measuring related statistics.
The master method carries
out three “passes” or processing steps in order to map the <code class="docutils literal notranslate"><span class="pre">slm</span></code> grids
(sla, slt, slc)
into grids of HSL and aspect, as well as to generate derivative data from them.</p>
<dl class="attribute">
<dt id="streamlines.mapping.Mapping.geodata">
<code class="descname">geodata</code><a class="headerlink" href="#streamlines.mapping.Mapping.geodata" title="Permalink to this definition">¶</a></dt>
<dd><p><em>instance</em> – of <a class="reference internal" href="geodata.html#streamlines.geodata.Geodata" title="streamlines.geodata.Geodata"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geodata</span></code></a> class</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.preprocess">
<code class="descname">preprocess</code><a class="headerlink" href="#streamlines.mapping.Mapping.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p><em>instance</em> – of <a class="reference internal" href="preprocess.html#streamlines.preprocess.Preprocess" title="streamlines.preprocess.Preprocess"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preprocess</span></code></a> class</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.trace">
<code class="descname">trace</code><a class="headerlink" href="#streamlines.mapping.Mapping.trace" title="Permalink to this definition">¶</a></dt>
<dd><p><em>instance</em> – of <a class="reference internal" href="trace.html#streamlines.trace.Trace" title="streamlines.trace.Trace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trace</span></code></a> class</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.analysis">
<code class="descname">analysis</code><a class="headerlink" href="#streamlines.mapping.Mapping.analysis" title="Permalink to this definition">¶</a></dt>
<dd><p><em>instance</em> – of <a class="reference internal" href="analysis.html#streamlines.analysis.Analysis" title="streamlines.analysis.Analysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Analysis</span></code></a> class</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.cl_state">
<code class="descname">cl_state</code><a class="headerlink" href="#streamlines.mapping.Mapping.cl_state" title="Permalink to this definition">¶</a></dt>
<dd><p><em>instance</em> – of <a class="reference internal" href="pocl.html#streamlines.pocl.Initialize_cl" title="streamlines.pocl.Initialize_cl"><code class="xref py py-class docutils literal notranslate"><span class="pre">Initialize_cl</span></code></a> class</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.mapping_array">
<code class="descname">mapping_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.mapping_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of uint32 pixel
container values, each a set of flags using during mapping</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.merged_coarse_mask_array">
<code class="descname">merged_coarse_mask_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.merged_coarse_mask_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of boolean pixel flags
indicating if the pixel is masked after merging
the set of coarsely subsegmented catchments</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.coarse_subsegment_array">
<code class="descname">coarse_subsegment_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.coarse_subsegment_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of int32 pixel values of
coarsely subsegmented catchment index</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.coarse_subsegments_list_array">
<code class="descname">coarse_subsegments_list_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.coarse_subsegments_list_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – sorted list of int32
coarsely subsegmented catchment indexes</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.n_coarse_subsegments">
<code class="descname">n_coarse_subsegments</code><a class="headerlink" href="#streamlines.mapping.Mapping.n_coarse_subsegments" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – number of unique values of
coarsely subsegmented catchment indexes</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_array">
<code class="descname">hsl_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of float32 pixel values
of the estimated hillslope length (HSL)</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_mean_array">
<code class="descname">hsl_mean_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_mean_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – list of float32 mean HSL values</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_stats_df">
<code class="descname">hsl_stats_df</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_stats_df" title="Permalink to this definition">¶</a></dt>
<dd><p><em>pandas.DataFrame</em> – container for HSL analysis &amp; statistics</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.aspect_array">
<code class="descname">aspect_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.aspect_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of float32 pixel values of
filtered topographic aspect aka hillslope azimuth</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.aspect_mask_array">
<code class="descname">aspect_mask_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.aspect_mask_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of boolean pixel flags
indicating if aspect computation is masked</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.channelhead_array">
<code class="descname">channelhead_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.channelhead_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of boolean pixel flags
indicating if at a channel head</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.midslope_array">
<code class="descname">midslope_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.midslope_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of boolean pixel flags
indicating if on a mid-slope band</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.ridge_array">
<code class="descname">ridge_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.ridge_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of boolean pixel flags
indicating if on a ridge</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.thinchannel_array">
<code class="descname">thinchannel_array</code><a class="headerlink" href="#streamlines.mapping.Mapping.thinchannel_array" title="Permalink to this definition">¶</a></dt>
<dd><p><em>numpy.ndarray</em> – map grid of boolean pixel flags
indicating if on a ‘thinned’ channel</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_ks">
<code class="descname">hsl_ns_ks</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_ks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> – results of K-S test of HSL N-S anisotropy</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_ks_nm">
<code class="descname">hsl_ns_ks_nm</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_ks_nm" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – K-S test of HSL N-S anisotropy,
partial <img class="math" src="../_images/math/09638d80aa315dddb31ee28d00fb299ae9a5488e.png" alt="D_\alpha"/></p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_ks_nmfactor">
<code class="descname">hsl_ns_ks_nmfactor</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_ks_nmfactor" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – K-S test of HSL N-S anisotropy,
partial <img class="math" src="../_images/math/09638d80aa315dddb31ee28d00fb299ae9a5488e.png" alt="D_\alpha"/></p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_ttest">
<code class="descname">hsl_ns_ttest</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_ttest" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> – results of Student’s t-test of HSL N-S anisotropy</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_mannwhitney">
<code class="descname">hsl_ns_mannwhitney</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_mannwhitney" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> – results of Mann-Whitney test of HSL N-S anisotropy</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_ranksum">
<code class="descname">hsl_ns_ranksum</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_ranksum" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> – results of rank-sum test of HSL N-S anisotropy</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_welch">
<code class="descname">hsl_ns_welch</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_welch" title="Permalink to this definition">¶</a></dt>
<dd><p><em>list</em> – results of Welch test of HSL N-S anisotropy</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_min">
<code class="descname">hsl_ns_min</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_min" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – HSL N-S minimum</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.hsl_ns_max">
<code class="descname">hsl_ns_max</code><a class="headerlink" href="#streamlines.mapping.Mapping.hsl_ns_max" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – HSL N-S maximum</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.verbose">
<code class="descname">verbose</code><a class="headerlink" href="#streamlines.mapping.Mapping.verbose" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bool</em> – general print verbosity flag</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.vbackup">
<code class="descname">vbackup</code><a class="headerlink" href="#streamlines.mapping.Mapping.vbackup" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bool</em> – temporary print verbosity flag</p>
</dd></dl>

<dl class="attribute">
<dt id="streamlines.mapping.Mapping.vprogress">
<code class="descname">vprogress</code><a class="headerlink" href="#streamlines.mapping.Mapping.vprogress" title="Permalink to this definition">¶</a></dt>
<dd><p><em>bool</em> – progress print verbosity flag</p>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>state</em>, <em>imported_parameters</em>, <em>geodata</em>, <em>preprocess</em>, <em>trace</em>, <em>analysis</em><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> (<em>instance</em>) – of <a class="reference internal" href="state.html#streamlines.state.State" title="streamlines.state.State"><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></a> class</li>
<li><strong>imported_parameters</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – parameters dictionary loaded from
an <code class="docutils literal notranslate"><span class="pre">slm</span></code>  <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.7)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">JSON</span></code></a> file.</li>
<li><strong>geodata</strong> (<em>instance</em>) – of <a class="reference internal" href="geodata.html#streamlines.geodata.Geodata" title="streamlines.geodata.Geodata"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geodata</span></code></a> class</li>
<li><strong>preprocess</strong> (<em>instance</em>) – of <a class="reference internal" href="preprocess.html#streamlines.preprocess.Preprocess" title="streamlines.preprocess.Preprocess"><code class="xref py py-class docutils literal notranslate"><span class="pre">Preprocess</span></code></a> class</li>
<li><strong>trace</strong> (<em>instance</em>) – of <a class="reference internal" href="trace.html#streamlines.trace.Trace" title="streamlines.trace.Trace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trace</span></code></a> class</li>
<li><strong>analysis</strong> (<em>instance</em>) – of <a class="reference internal" href="analysis.html#streamlines.analysis.Analysis" title="streamlines.analysis.Analysis"><code class="xref py py-class docutils literal notranslate"><span class="pre">Analysis</span></code></a> class</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Initialize a mapping class instance.</p>
<p>Provides hooks to key classes in <a class="reference internal" href="geodata.html#module-streamlines.geodata" title="streamlines.geodata"><code class="xref py py-mod docutils literal notranslate"><span class="pre">geodata</span></code></a>, <a class="reference internal" href="preprocess.html#module-streamlines.preprocess" title="streamlines.preprocess"><code class="xref py py-mod docutils literal notranslate"><span class="pre">preprocess</span></code></a>,
<a class="reference internal" href="trace.html#module-streamlines.trace" title="streamlines.trace"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trace</span></code></a>, and <a class="reference internal" href="analysis.html#module-streamlines.analysis" title="streamlines.analysis"><code class="xref py py-mod docutils literal notranslate"><span class="pre">analysis</span></code></a> modules.
Initializes the OpenCL device and a context, and creates a command queue.
Initializes (nulls) HSL statistics attributes.</p>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping._augment">
<code class="descname">_augment</code><span class="sig-paren">(</span><em>plot</em><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping._augment" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>plot</strong> (<em>reference</em>) – to <a class="reference internal" href="plot.html#streamlines.plot.Plot" title="streamlines.plot.Plot"><code class="xref py py-class docutils literal notranslate"><span class="pre">Plot</span></code></a> instance</td>
</tr>
</tbody>
</table>
<p>Add a hook to the <a class="reference internal" href="plot.html#streamlines.plot.Plot" title="streamlines.plot.Plot"><code class="xref py py-class docutils literal notranslate"><span class="pre">Plot</span></code></a> class to facilitate debug graphing.
Invoked in <a class="reference internal" href="streamlining.html#module-streamlines.streamlining" title="streamlines.streamlining"><code class="xref py py-mod docutils literal notranslate"><span class="pre">streamlining</span></code></a> module, not here.</p>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.do">
<code class="descname">do</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.do" title="Permalink to this definition">¶</a></dt>
<dd><p>Master method to carry out all three steps of HSL &amp; related mapping
and computation of statistics:</p>
<p>TBD TBD TBD TBD TBD TBD TBD TBD TBD</p>
<ol class="arabic simple">
<li>Estimate the DTM-wide channel threshold and use it
to coarsely subsegment into “moderate”-size watersheds
- where “sub” means split into L and R flanks along channels</li>
<li><dl class="first docutils">
<dt>Iterate over the coarse subsegments and in each:</dt>
<dd><ul class="first last">
<li>estimate the channel threshold</li>
<li>map channels, ridges &amp; midslopes</li>
<li>measure HSL from either ridges or midslopes to channels</li>
<li>merge the HSL and (TBD) channel mapping into “global” results grid(s)</li>
</ul>
</dd>
</dl>
</li>
<li>Filter the HSL results into a smoothed, contourable grid
Compute filtered terrain aspect and combine with this HSL grid
Generate a mean HSL(aspect) function and related statistics
to determine whether or not there is a N-S bias</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.do_map_channels_segments">
<code class="descname">do_map_channels_segments</code><span class="sig-paren">(</span><em>info</em>, <em>data</em>, <em>do_map_channels_from_scratch=True</em>, <em>do_map_segments=True</em><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.do_map_channels_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>TBD.</p>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.make_coarse_subsegment_masks">
<code class="descname">make_coarse_subsegment_masks</code><span class="sig-paren">(</span><em>coarse_subsegment</em>, <em>is_left_or_right</em>, <em>raw_mask</em>, <em>dilated_mask</em><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.make_coarse_subsegment_masks" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>coarse_subsegment</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – index of coarse catchment subsegment</li>
<li><strong>is_left_or_right</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – string-flag indicating if subsegment is left or right
flank (“left” subsegments need dilation=2,
“right” need dilation=1)</li>
<li><strong>raw_mask</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – empty grid for raw coarse subsegment mask</li>
<li><strong>dilated_mask</strong> (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><em>numpy.ndarray</em></a>) – empty grid for dilated coarse subsegment mask</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Create a boolean mask grid for the given coarse catchment subsegment.
Returns masks in the raw_mask and dilated_mask grids by modifying in place.
Computes bounding box (grid coords) of the dilated mask in bbox_dilated_mask
and its dimensions nxd,nyd.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">bbox_dilated_mask, nxd,nyd</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)">list</a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)">int</a>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)">int</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.pass1">
<code class="descname">pass1</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.pass1" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass or stage 1 of HSL mapping.</p>
<p>Estimate the DTM-wide channel threshold and use it
to coarsely subsegment into “moderate”-size watersheds.
Note that the “sub” prefix means that each segment is split
into left and right flanks along its channel, with an attempt made to
subdivide symmetrically above each channel head (this is not always
very successful).</p>
<dl class="docutils">
<dt>Key steps:</dt>
<dd><ol class="first last arabic simple">
<li>Generate a mask that excludes non-mappable pixels; record its bounding box</li>
<li>Map channels &amp; catchments (sub)segments in a preliminary, coarse fashion</li>
<li>Generate a mask that includes all coarse subsegment pixels</li>
<li>Map mid-slope and ridge pixels using sla values only</li>
</ol>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.pass2">
<code class="descname">pass2</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.pass2" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass or stage 2 of HSL mapping.</p>
<dl class="docutils">
<dt>Iterate over the coarse subsegments and in each:</dt>
<dd><ul class="first last simple">
<li>estimate the channel threshold</li>
<li>map channels, ridges &amp; midslopes</li>
<li>measure HSL from either ridges or midslopes to channels</li>
<li>merge the HSL and (TBD) channel mapping into “global” results grid(s)</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="streamlines.mapping.Mapping.pass3">
<code class="descname">pass3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#streamlines.mapping.Mapping.pass3" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass or stage 3 of HSL mapping.</p>
<ul class="simple">
<li>Filter the HSL results into a smoothed, contourable grid.</li>
<li>Compute filtered terrain aspect and combine with this HSL grid.</li>
<li>Generate a mean HSL(aspect) function and related statistics
to determine whether or not there is a N-S bias.</li>
</ul>
</dd></dl>

</dd></dl>

<div class="section" id="code">
<h2>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">---------------------------------------------------------------------</span>

<span class="sd">Module for mapping channels, channel heads, subcatchment segmentation,</span>
<span class="sd">hillslope length (HSL), and filtered topographic aspect, and for analyzing azimuthal</span>
<span class="sd">variations.</span>

<span class="sd">---------------------------------------------------------------------</span>

<span class="sd">Requires Python packages/modules:</span>
<span class="sd">  -  :mod:`pandas` </span>
<span class="sd">  -  :mod:`sklearn.preprocessing`</span>
<span class="sd">  -  :mod:`skimage.morphology`</span>
<span class="sd">  -  :mod:`skimage.filters`</span>
<span class="sd">  -  :mod:`scipy.ndimage`</span>
<span class="sd">  -  :mod:`scipy.stats`</span>
<span class="sd">  -  :mod:`scipy.interpolate`</span>
<span class="sd">  -  :mod:`skfmm`</span>

<span class="sd">Imports ``slm`` modules:</span>
<span class="sd">  -  :mod:`.connect`</span>
<span class="sd">  -  :mod:`.channelheads`</span>
<span class="sd">  -  :mod:`.countlink`</span>
<span class="sd">  -  :mod:`.label`</span>
<span class="sd">  -  :mod:`.segment`</span>
<span class="sd">  -  :mod:`.hillslopes`</span>
<span class="sd">  -  :mod:`.lengths`</span>

<span class="sd">Imports the :class:`.Core` class.</span>

<span class="sd">Imports classes &amp; functions from:</span>
<span class="sd">  -  :mod:`.useful`</span>
<span class="sd">  -  :mod:`.pocl`</span>


<span class="sd">---------------------------------------------------------------------</span>

<span class="sd">.. _pandas: https://pandas.pydata.org/</span>
<span class="sd">.. _sklearn: http://scikit-learn.org/</span>
<span class="sd">.. _skimage: https://scikit-image.org/</span>
<span class="sd">.. _scipy: https://www.scipy.org/</span>
<span class="sd">.. _skfmm: https://pythonhosted.org/scikit-fmm/</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>  <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">cmath</span> <span class="k">import</span> <span class="n">rect</span><span class="p">,</span> <span class="n">polar</span>
<span class="kn">import</span> <span class="nn">sklearn</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">normalize</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span>    <span class="k">import</span> <span class="n">skeletonize</span><span class="p">,</span> <span class="n">thin</span><span class="p">,</span> <span class="n">medial_axis</span><span class="p">,</span> <span class="n">disk</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span>       <span class="k">import</span> <span class="n">gaussian</span>
<span class="kn">from</span> <span class="nn">skimage.filters.rank</span>  <span class="k">import</span> <span class="n">mean</span><span class="p">,</span> <span class="n">median</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span>            <span class="k">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="k">import</span> <span class="n">binary_fill_holes</span><span class="p">,</span> <span class="n">grey_dilation</span><span class="p">,</span> \
                                     <span class="n">binary_dilation</span><span class="p">,</span> <span class="n">binary_erosion</span><span class="p">,</span> \
                                     <span class="n">generate_binary_structure</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">ks_2samp</span><span class="p">,</span> <span class="n">mannwhitneyu</span><span class="p">,</span> <span class="n">ranksums</span><span class="p">,</span> <span class="n">ttest_ind</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span> 
<span class="kn">import</span> <span class="nn">skfmm</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">environ</span>
<span class="n">environ</span><span class="p">[</span><span class="s1">&#39;PYTHONUNBUFFERED&#39;</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;True&#39;</span>

<span class="kn">from</span> <span class="nn">streamlines</span>        <span class="k">import</span> <span class="n">connect</span><span class="p">,</span> <span class="n">channelheads</span><span class="p">,</span> <span class="n">countlink</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> \
                               <span class="n">segment</span><span class="p">,</span> <span class="n">hillslopes</span><span class="p">,</span> <span class="n">lengths</span>
<span class="kn">from</span> <span class="nn">streamlines.core</span>   <span class="k">import</span> <span class="n">Core</span>
<span class="kn">from</span> <span class="nn">streamlines.useful</span> <span class="k">import</span> <span class="n">Data</span><span class="p">,</span> <span class="n">Info</span><span class="p">,</span> <span class="n">vprint</span><span class="p">,</span> <span class="n">dilate</span><span class="p">,</span> <span class="n">get_bbox</span><span class="p">,</span> <span class="n">npamem</span>
<span class="kn">from</span> <span class="nn">streamlines.pocl</span>   <span class="k">import</span> <span class="n">Initialize_cl</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mapping&#39;</span><span class="p">]</span>

<span class="n">pdebug</span> <span class="o">=</span> <span class="nb">print</span>

<span class="k">class</span> <span class="nc">Mapping</span><span class="p">(</span><span class="n">Core</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class providing methods to map and characterize hillslope length (HSL) </span>
<span class="sd">    across a DTM.</span>
<span class="sd">    </span>
<span class="sd">    These methods do the bulk of the hard work in mapping hillslope length, </span>
<span class="sd">    in linking to topographic aspect, and in measuring related statistics. </span>
<span class="sd">    The master method carries</span>
<span class="sd">    out three &quot;passes&quot; or processing steps in order to map the ``slm`` grids</span>
<span class="sd">    (sla, slt, slc)</span>
<span class="sd">    into grids of HSL and aspect, as well as to generate derivative data from them.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        geodata (instance):    of :class:`.Geodata` class</span>
<span class="sd">        preprocess (instance): of :class:`.Preprocess` class</span>
<span class="sd">        trace (instance):      of :class:`.Trace` class</span>
<span class="sd">        analysis (instance):   of :class:`.Analysis` class</span>
<span class="sd">        cl_state (instance):   of :class:`.Initialize_cl` class</span>
<span class="sd">        </span>
<span class="sd">        mapping_array (numpy.ndarray): map grid of uint32 pixel </span>
<span class="sd">            container values, each a set of flags using during mapping</span>
<span class="sd">        merged_coarse_mask_array (numpy.ndarray): map grid of boolean pixel flags</span>
<span class="sd">            indicating if the pixel is masked after merging</span>
<span class="sd">            the set of coarsely subsegmented catchments</span>
<span class="sd">        coarse_subsegment_array (numpy.ndarray):  map grid of int32 pixel values of  </span>
<span class="sd">            coarsely subsegmented catchment index </span>
<span class="sd">        coarse_subsegments_list_array (numpy.ndarray): sorted list of int32</span>
<span class="sd">            coarsely subsegmented catchment indexes</span>
<span class="sd">        n_coarse_subsegments (int): number of unique values of</span>
<span class="sd">            coarsely subsegmented catchment indexes</span>

<span class="sd">        hsl_array (numpy.ndarray): map grid of float32 pixel values </span>
<span class="sd">            of the estimated hillslope length (HSL)</span>
<span class="sd">        hsl_mean_array (numpy.ndarray): list of float32 mean HSL values</span>
<span class="sd">        hsl_stats_df (pandas.DataFrame): container for HSL analysis &amp; statistics</span>

<span class="sd">        aspect_array (numpy.ndarray):  map grid of float32 pixel values of  </span>
<span class="sd">            filtered topographic aspect aka hillslope azimuth</span>
<span class="sd">        aspect_mask_array (numpy.ndarray): map grid of boolean pixel flags</span>
<span class="sd">            indicating if aspect computation is masked</span>
<span class="sd">        channelhead_array (numpy.ndarray):  map grid of boolean pixel flags</span>
<span class="sd">            indicating if at a channel head</span>
<span class="sd">        midslope_array (numpy.ndarray):  map grid of boolean pixel flags</span>
<span class="sd">            indicating if on a mid-slope band</span>
<span class="sd">        ridge_array (numpy.ndarray):  map grid of boolean pixel flags</span>
<span class="sd">            indicating if on a ridge</span>
<span class="sd">        thinchannel_array (numpy.ndarray): map grid of boolean pixel flags</span>
<span class="sd">            indicating if on a &#39;thinned&#39; channel</span>


<span class="sd">        hsl_ns_ks (list):          results of K-S test of HSL N-S anisotropy </span>
<span class="sd">        hsl_ns_ks_nm (float):      K-S test of HSL N-S anisotropy, </span>
<span class="sd">           partial :math:`D_\\alpha`</span>
<span class="sd">        hsl_ns_ks_nmfactor (float): K-S test of HSL N-S anisotropy, </span>
<span class="sd">           partial :math:`D_\\alpha`</span>
<span class="sd">        hsl_ns_ttest (list):       results of Student&#39;s t-test of HSL N-S anisotropy </span>
<span class="sd">        hsl_ns_mannwhitney (list): results of Mann-Whitney test of HSL N-S anisotropy </span>
<span class="sd">        hsl_ns_ranksum (list):     results of rank-sum test of HSL N-S anisotropy </span>
<span class="sd">        hsl_ns_welch (list):       results of Welch test of HSL N-S anisotropy </span>
<span class="sd">        hsl_ns_min (float):        HSL N-S minimum</span>
<span class="sd">        hsl_ns_max (float):        HSL N-S maximum</span>

<span class="sd">        verbose (bool):         general print verbosity flag</span>
<span class="sd">        vbackup (bool):         temporary print verbosity flag</span>
<span class="sd">        vprogress (bool):       progress print verbosity flag</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">,</span><span class="n">imported_parameters</span><span class="p">,</span><span class="n">geodata</span><span class="p">,</span><span class="n">preprocess</span><span class="p">,</span><span class="n">trace</span><span class="p">,</span><span class="n">analysis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            state (instance):      of :class:`.State` class</span>
<span class="sd">            imported_parameters (dict): parameters dictionary loaded from </span>
<span class="sd">                                         an ``slm``  :py:mod:`JSON &lt;json&gt;` file.</span>
<span class="sd">            geodata (instance):    of :class:`.Geodata` class</span>
<span class="sd">            preprocess (instance): of :class:`.Preprocess` class</span>
<span class="sd">            trace (instance):      of :class:`.Trace` class</span>
<span class="sd">            analysis (instance):   of :class:`.Analysis` class</span>
<span class="sd">            </span>
<span class="sd">        Initialize a mapping class instance.</span>

<span class="sd">        Provides hooks to key classes in :mod:`.geodata`, :mod:`.preprocess`, </span>
<span class="sd">        :mod:`.trace`, and :mod:`.analysis` modules.</span>
<span class="sd">        Initializes the OpenCL device and a context, and creates a command queue.</span>
<span class="sd">        Initializes (nulls) HSL statistics attributes.</span>
<span class="sd">        </span>

<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">imported_parameters</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span> <span class="o">=</span> <span class="n">geodata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">preprocess</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trace</span> <span class="o">=</span> <span class="n">trace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span> <span class="o">=</span> <span class="n">analysis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span> <span class="o">=</span> <span class="n">Initialize_cl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cl_src_path</span><span class="p">,</span> 
                                      <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cl_platform</span><span class="p">,</span> 
                                      <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">cl_device</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vbackup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">verbose</span>
        <span class="c1"># Just in case of a problem, flag incomplete processing with empty objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks_nm</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks_nmfactor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks</span>          <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ttest</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_mannwhitney</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ranksum</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_welch</span>       <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_min</span>         <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_max</span>         <span class="o">=</span> <span class="kc">None</span>
    
    <span class="k">def</span> <span class="nf">_augment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            plot (reference):  to :class:`.Plot` instance</span>
<span class="sd">            </span>
<span class="sd">        Add a hook to the :class:`.Plot` class to facilitate debug graphing.</span>
<span class="sd">        Invoked in :mod:`.streamlining` module, not here.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span> <span class="o">=</span> <span class="n">plot</span>
     
     
    <span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Master method to carry out all three steps of HSL &amp; related mapping</span>
<span class="sd">        and computation of statistics:</span>
<span class="sd">        </span>
<span class="sd">        TBD TBD TBD TBD TBD TBD TBD TBD TBD </span>
<span class="sd">        </span>
<span class="sd">        1) Estimate the DTM-wide channel threshold and use it </span>
<span class="sd">           to coarsely subsegment into &quot;moderate&quot;-size watersheds</span>
<span class="sd">           - where &quot;sub&quot; means split into L and R flanks along channels</span>

<span class="sd">        2) Iterate over the coarse subsegments and in each:</span>
<span class="sd">            - estimate the channel threshold</span>
<span class="sd">            - map channels, ridges &amp; midslopes</span>
<span class="sd">            - measure HSL from either ridges or midslopes to channels</span>
<span class="sd">            - merge the HSL and (TBD) channel mapping into &quot;global&quot; results grid(s)</span>

<span class="sd">        3) Filter the HSL results into a smoothed, contourable grid</span>
<span class="sd">           Compute filtered terrain aspect and combine with this HSL grid</span>
<span class="sd">           Generate a mean HSL(aspect) function and related statistics</span>
<span class="sd">           to determine whether or not there is a N-S bias</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">**Mapping begin**&#39;</span><span class="p">)</span> 
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_pass1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pass1</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_pass2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pass2</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_pass3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pass3</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;**Mapping end**</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>  

    <span class="k">def</span> <span class="nf">pass1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass or stage 1 of HSL mapping.</span>
<span class="sd">        </span>
<span class="sd">        Estimate the DTM-wide channel threshold and use it </span>
<span class="sd">        to coarsely subsegment into &quot;moderate&quot;-size watersheds.</span>
<span class="sd">        Note that the &quot;sub&quot; prefix means that each segment is split </span>
<span class="sd">        into left and right flanks along its channel, with an attempt made to </span>
<span class="sd">        subdivide symmetrically above each channel head (this is not always</span>
<span class="sd">        very successful).</span>
<span class="sd">        </span>
<span class="sd">        Key steps:</span>
<span class="sd">            1) Generate a mask that excludes non-mappable pixels; record its bounding box</span>
<span class="sd">            2) Map channels &amp; catchments (sub)segments in a preliminary, coarse fashion</span>
<span class="sd">            3) Generate a mask that includes all coarse subsegment pixels</span>
<span class="sd">            4) Map mid-slope and ridge pixels using sla values only</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">**Pass#1 begin**&#39;</span><span class="p">)</span>
<span class="c1">#         self._switch_to_quiet_mode()</span>
        <span class="c1"># Shorthand</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pad_width</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_nx</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_ny</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="mi">2</span>
        <span class="c1"># Create arrays for mapping and coarse subsegmentation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegment_array</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_coarse_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span>  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="c1"># Create an info object for passing parameters to CL wrappers etc</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Revert to &#39;dtm&#39;, &#39;basin&#39; (if set), and &#39;uv&#39; masks only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset_active_masks</span><span class="p">()</span>
        <span class="c1"># Generate a combined mask array from this set</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">()</span>
        <span class="c1"># Find the bounding box of this mask and its x,y size</span>
        <span class="n">bbox</span><span class="p">,</span> <span class="n">nxb</span><span class="p">,</span> <span class="n">nyb</span> <span class="o">=</span> <span class="n">get_bbox</span><span class="p">(</span><span class="o">~</span><span class="n">mask_array</span><span class="p">)</span>
        <span class="c1"># Record this bbox, its padding, its x,y size and the padded x,y size</span>
        <span class="c1"># BUG - need boundary masking</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_xy</span><span class="p">(</span><span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
        <span class="c1"># Force coarse subsegmentation and related dummy channel thresholds</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_thresholds</span><span class="p">(</span><span class="n">channel_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coarse_channel_threshold</span><span class="p">,</span>
                            <span class="n">segmentation_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coarse_segmentation_threshold</span><span class="p">)</span>
        <span class="c1"># Create a data array container</span>
        <span class="c1">#   - these arrays are sliced from their source arrays bounded by the padded bbox</span>
        <span class="c1">#   - slicing bounds for simple arrays and for two-layer (up &amp; downstream)</span>
        <span class="c1">#     arrays are recorded in data.bounds_grid and data.bounds_slx respectively. </span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                     <span class="n">mapping_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">,</span>
                     <span class="n">mask_array</span>    <span class="o">=</span> <span class="n">mask_array</span><span class="p">,</span>
                     <span class="n">uv_array</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="o">.</span><span class="n">uv_array</span><span class="p">,</span>
                     <span class="n">slc_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">slc_array</span><span class="p">,</span>
                     <span class="n">slt_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">slt_array</span><span class="p">,</span>
                     <span class="n">sla_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">sla_array</span> <span class="p">)</span>
        
        <span class="c1"># Map midslope lines </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_midslopes</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_ridges</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        
        <span class="c1"># Do the forced coarse channel mapping &amp; subsegmentation</span>
        <span class="c1">#   - the flag &#39;do_map_channels_from_scratch&#39; will default to true</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_map_channels_segments</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;A problem during mapping channels &amp; segments&#39;</span><span class="p">)</span>
    
        <span class="c1"># Save the coarse subsegmentation labels</span>
        <span class="c1">#   - inserted into full size grid arrays using the data.bounds_grid slice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">bounds_grid</span><span class="p">]</span>           <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegment_array</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">bounds_grid</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">label_array</span>
        <span class="c1"># Make a list of all the subsegments with enough ridge/midslope pixels for HSL</span>
        <span class="n">coarse_subsegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">[</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask_array</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegments_list_array</span> \
            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">coarse_subsegments</span><span class="p">[</span><span class="n">coarse_subsegments</span><span class="o">!=</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_coarse_subsegments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegments_list_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Make a mask to select all coarse subsegments</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegments_list_array</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merged_coarse_mask_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegment_array</span><span class="o">==</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Copy the coarse subsegments so they can be readily visualized</span>
    <span class="c1">#         self.label_array = self.coarse_subsegment_array.copy()</span>
    <span class="c1">#         self._switch_back_to_verbose_mode()</span>
    
        <span class="k">del</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset_active_masks</span><span class="p">()</span>
            
        <span class="c1"># Map HSL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Prepare for mapping HSL from </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">(</span><span class="s1">&#39;ridges&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_measure_hsl_from_ridges</span> <span class="k">else</span> <span class="s1">&#39;midslopes&#39;</span><span class="p">)))</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">()</span>
        <span class="n">bbox</span><span class="p">,</span> <span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span> <span class="o">=</span> <span class="n">get_bbox</span><span class="p">(</span><span class="o">~</span><span class="n">mask_array</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_xy</span><span class="p">(</span><span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_thresholds</span><span class="p">(</span><span class="n">segmentation_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fine_segmentation_threshold</span><span class="p">)</span>
        <span class="c1"># Here data.bounds_grid is computed</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                     <span class="n">mapping_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">,</span>
                     <span class="n">mask_array</span>    <span class="o">=</span> <span class="n">mask_array</span><span class="p">)</span>
<span class="c1">#                          sla_array     = self.trace.sla_array )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">bounds_grid</span>
        <span class="c1"># Should we zero out all but ridge &amp; midslope flags? </span>
        <span class="c1"># What about after pass#2 (keeping channel heads)?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">][</span><span class="o">~</span><span class="n">mask_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">]]</span> \
                <span class="o">|=</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="o">~</span><span class="n">mask_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">]]</span>
        <span class="c1"># Erase pass#1 channel heads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="o">&amp;</span><span class="n">info</span><span class="o">.</span><span class="n">is_channelhead</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>\
                            <span class="o">^=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channelhead</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="o">&amp;</span><span class="n">info</span><span class="o">.</span><span class="n">is_thinchannel</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>\
                            <span class="o">^=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_thinchannel</span>

        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;**Pass#1 end**&#39;</span><span class="p">)</span> 

    <span class="k">def</span> <span class="nf">make_coarse_subsegment_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coarse_subsegment</span><span class="p">,</span> <span class="n">is_left_or_right</span><span class="p">,</span>
                                     <span class="n">raw_mask</span><span class="p">,</span> <span class="n">dilated_mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            coarse_subsegment (int): index of coarse catchment subsegment</span>
<span class="sd">            is_left_or_right (str): string-flag indicating if subsegment is left or right</span>
<span class="sd">                                    flank (&quot;left&quot; subsegments need dilation=2, </span>
<span class="sd">                                    &quot;right&quot; need dilation=1)</span>
<span class="sd">            raw_mask (numpy.ndarray): empty grid for raw coarse subsegment mask</span>
<span class="sd">            dilated_mask (numpy.ndarray): empty grid for dilated coarse subsegment mask</span>
<span class="sd">        </span>
<span class="sd">        Create a boolean mask grid for the given coarse catchment subsegment.</span>
<span class="sd">        Returns masks in the raw_mask and dilated_mask grids by modifying in place.</span>
<span class="sd">        Computes bounding box (grid coords) of the dilated mask in bbox_dilated_mask  </span>
<span class="sd">        and its dimensions nxd,nyd.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list, int, int:</span>
<span class="sd">            bbox_dilated_mask, nxd,nyd </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize raw mask with masked everywhere</span>
        <span class="n">raw_mask</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Unmask this coarse segment</span>
        <span class="n">raw_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegment_array</span><span class="o">==</span><span class="n">coarse_subsegment</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Dilate this coarse segment mask by 2 if left or 1 if right flank</span>
        <span class="c1">#   - cos left dilation needs to grow to cover right-flank channel pixels</span>
        <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="k">if</span> <span class="n">is_left_or_right</span><span class="o">==</span><span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">dilate</span><span class="p">(</span><span class="o">~</span><span class="n">raw_mask</span><span class="p">,</span><span class="n">n_iterations</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">dilated_mask</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">dilated_mask</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">dilated_mask</span><span class="p">)</span>
        <span class="c1"># Shorthand</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pad_width</span>
        <span class="c1"># Ensure dilated unmask does not encroach on boundary mask</span>
        <span class="n">dilated_mask</span><span class="p">[:</span><span class="n">pad</span><span class="p">,:]</span>  <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dilated_mask</span><span class="p">[:,:</span><span class="n">pad</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dilated_mask</span><span class="p">[</span><span class="o">-</span><span class="n">pad</span><span class="p">:,:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dilated_mask</span><span class="p">[:,</span><span class="o">-</span><span class="n">pad</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Define bbox and dimensions of the dilated mask</span>
        <span class="n">bbox_dilated_mask</span><span class="p">,</span> <span class="n">nxd</span><span class="p">,</span><span class="n">nyd</span> <span class="o">=</span> <span class="n">get_bbox</span><span class="p">(</span><span class="o">~</span><span class="n">dilated_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bbox_dilated_mask</span><span class="p">,</span> <span class="n">nxd</span><span class="p">,</span><span class="n">nyd</span>

    <span class="k">def</span> <span class="nf">pass2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass or stage 2 of HSL mapping.</span>
<span class="sd">        </span>
<span class="sd">        Iterate over the coarse subsegments and in each:</span>
<span class="sd">          - estimate the channel threshold</span>
<span class="sd">          - map channels, ridges &amp; midslopes</span>
<span class="sd">          - measure HSL from either ridges or midslopes to channels</span>
<span class="sd">          - merge the HSL and (TBD) channel mapping into &quot;global&quot; results grid(s)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">**Pass#2 begin**&#39;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_switch_to_quiet_mode</span><span class="p">()</span>
        <span class="c1"># Shorthand</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pad_width</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_nx</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_ny</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">pixel_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span>
        <span class="c1"># Count how many coarse subsegments need to be iterated over</span>
        <span class="n">n_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_coarse_subsegments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Subsegment labels: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_segments</span><span class="p">))</span>
        <span class="c1"># Mask off all but these coarse subsegments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_active_mask</span><span class="p">({</span><span class="s1">&#39;merged_coarse&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_coarse_mask_array</span><span class="p">})</span>
        <span class="c1"># Initialize the full ROI-scale HSL grid and a buffer</span>
        <span class="c1"># Also a mapping array for channels etc</span>
        <span class="n">raw_mask_array</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">dilated_mask_array</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">merged_mask_array</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_array</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_stats_df</span>   <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Iterate over the coarse subsegments</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">coarse_subsegment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coarse_subsegments_list_array</span><span class="p">):</span>
<span class="c1">#         for idx,coarse_subsegment in enumerate([71]):</span>
            <span class="k">if</span> <span class="n">idx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">merged_mask_array</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="c1">#             if (coarse_subsegment)!=-4 and (coarse_subsegment)!=-3:</span>
<span class="c1">#                 continue</span>
            <span class="c1"># Report % progress</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">report_progress</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">,</span> <span class="n">subsegment</span><span class="o">=</span><span class="n">coarse_subsegment</span><span class="p">)</span>
            <span class="c1"># Revert to &#39;dtm&#39;, &#39;basin&#39; (if set), and &#39;uv&#39; masks only</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset_active_masks</span><span class="p">()</span>
            <span class="c1"># Flag if this coarse subsegment is left or right flank</span>
            <span class="c1">#   - important because a left flank subseg omits the channel pixels</span>
            <span class="n">is_left_or_right</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span> <span class="k">if</span> <span class="n">coarse_subsegment</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="c1"># Convert this coarse subsegment-labeled pixels into a mask</span>
            <span class="c1">#    - also dilate this pixel set and generate a wider mask </span>
            <span class="c1">#      to ensure flank-adjacent channel pixels are incorporated </span>
            <span class="c1">#    - dilate by 1 for R flank and by 2 for L flank to ensure this</span>
            <span class="n">bbox</span><span class="p">,</span> <span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_coarse_subsegment_masks</span><span class="p">(</span><span class="n">coarse_subsegment</span><span class="p">,</span> <span class="n">is_left_or_right</span><span class="p">,</span>
                                                    <span class="n">raw_mask_array</span><span class="p">,</span> <span class="n">dilated_mask_array</span><span class="p">)</span>
            <span class="c1"># Create metadata container for this coarse subsegment</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> 
                        <span class="n">coarse_label</span><span class="o">=</span><span class="n">coarse_subsegment</span><span class="p">)</span>
            <span class="n">info</span><span class="o">.</span><span class="n">set_xy</span><span class="p">(</span><span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;--- Mapping HSL on subsegment §</span><span class="si">{0}</span><span class="s1"> = </span><span class="si">{1}</span><span class="s1">/</span><span class="si">{2}</span><span class="s1"> (</span><span class="si">{3}</span><span class="s1">)&#39;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coarse_subsegment</span><span class="p">,</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n_segments</span><span class="p">,</span><span class="n">is_left_or_right</span><span class="p">))</span>
            <span class="c1"># Deploy the dilated coarse-subsegment mask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_active_mask</span><span class="p">({</span><span class="s1">&#39;dilated_segment&#39;</span><span class="p">:</span> <span class="n">dilated_mask_array</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">merged_mask_array</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Dilated coarse subsegment mask bounding box: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bbox</span><span class="p">))</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                         <span class="n">mapping_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">,</span>
                         <span class="n">mask_array</span>    <span class="o">=</span> <span class="n">merged_mask_array</span><span class="p">,</span>
                         <span class="n">uv_array</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="o">.</span><span class="n">uv_array</span><span class="p">,</span>
                         <span class="n">slc_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">slc_array</span><span class="p">,</span>
                         <span class="n">slt_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">slt_array</span><span class="p">,</span>
                         <span class="n">sla_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">sla_array</span> <span class="p">)</span>

            <span class="c1"># Compute slt pdf and estimate channel threshold from it</span>
            <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">estimate_channel_threshold</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vbackup</span><span class="p">)</span>
            <span class="c1"># Don&#39;t HSL map if there&#39;s a problem with channel threshold estimation here</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_channel_threshold</span>
<span class="c1">#                 vprint(self.vprogress,&#39;   ---&#39;)</span>
<span class="c1">#                 continue</span>
            <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">max_channel_threshold</span><span class="p">:</span> 
                <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_channel_threshold</span>
<span class="c1">#                 vprint(self.vprogress,&#39;   ---&#39;)</span>
<span class="c1">#                 continue</span>
            <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">min_channel_threshold</span><span class="p">:</span> 
                <span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">guess_channel_threshold</span><span class="o">/</span><span class="mi">2</span>
<span class="c1">#                 vprint(self.vprogress,&#39;   ---&#39;)</span>
<span class="c1">#                 continue</span>
            <span class="n">info</span><span class="o">.</span><span class="n">set_thresholds</span><span class="p">(</span><span class="n">channel_threshold</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span><span class="p">,</span>
                                <span class="n">segmentation_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fine_segmentation_threshold</span><span class="p">)</span>
            
            <span class="c1"># Big step - map subsegments using above channel threshold</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_map_channels_segments</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">data</span>
                <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;   --- (problem mapping channels &amp; subsegments)&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
            
            <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[(</span><span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channelhead</span>
                                <span class="o">==</span><span class="n">info</span><span class="o">.</span><span class="n">is_channelhead</span> <span class="p">)]</span> \
                <span class="o">|=</span> <span class="n">info</span><span class="o">.</span><span class="n">was_channelhead</span>
            
            
            <span class="c1"># Map using FMM</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select_subsegments</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">do_restrict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">measure_hsl_fmm</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> \
                  <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_hsl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> \
                  <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">remap_hsl</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_hsl_averaging_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">data</span>
                <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;   --- (problem measuring HSL using FM)&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
            
<span class="c1">#             # Map using streamlines</span>
<span class="c1">#             self.select_subsegments(info, data)</span>
<span class="c1">#             if not self.measure_hsl_traced(info, data) \</span>
<span class="c1">#                      or not self.parse_hsl(info, data) \</span>
<span class="c1">#                      or not self.remap_hsl(info, data):</span>
<span class="c1">#                 del data</span>
<span class="c1">#                 vprint(self.vprogress,&#39;   ---&#39;)</span>
<span class="c1">#                 continue</span>
            
<span class="c1">#             if (coarse_subsegment)==-4 or (coarse_subsegment)==-3:</span>
<span class="c1">#                 self.plot.plot_distributions()</span>
            
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span>
                   <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Channel threshold = </span><span class="si">{0:0.1f}</span><span class="s1">m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">channel_threshold</span><span class="p">))</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span>
                   <span class="s1">&#39;FMM mean HSL   = </span><span class="si">{0:0.1f}</span><span class="s1">m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">fmm_mean_hsl</span><span class="p">))</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span>
                   <span class="s1">&#39;Trace mean HSL = </span><span class="si">{0:0.1f}</span><span class="s1">m&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">trace_mean_hsl</span><span class="p">))</span>
            <span class="c1"># Inefficient but simple</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_array</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">trace_mean_hsl</span><span class="p">)</span>
            <span class="c1"># Eliminate almost certainly spurious count=1 HSL mean values</span>
<span class="c1">#             data.hsl_stats_df = data.hsl_stats_df[data.hsl_stats_df[&#39;count&#39;]&gt;1]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_stats_df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hsl_stats_df</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> 
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="p">[</span><span class="s1">&#39;mean [m]&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">5.0</span><span class="p">)</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hsl_stats_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> 
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span><span class="p">[</span><span class="s1">&#39;mean [m]&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mf">5.0</span><span class="p">)</span>
                    <span class="p">])</span>
            
            <span class="c1"># Remove this iteration&#39;s dilated coarse-subsegment mask</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">remove_active_mask</span><span class="p">(</span><span class="s1">&#39;dilated_segment&#39;</span><span class="p">)</span>
            <span class="c1"># Deploy this coarse subsegment&#39;s HSL data to the &#39;global&#39; HSL map</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Merging hillslope lengths...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># Use raw coarse mask to only keep HSL values actually on coarse subsegment</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_active_mask</span><span class="p">({</span><span class="s1">&#39;raw_segment&#39;</span><span class="p">:</span> <span class="n">raw_mask_array</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="n">merged_mask_array</span><span class="p">)</span>
            <span class="c1"># Merge this coarse subsegment&#39;s HSL values into the &#39;global&#39; HSL map</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">bounds_grid</span>
            <span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">][</span><span class="o">~</span><span class="n">merged_mask_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">]]</span> \
                <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="o">~</span><span class="n">merged_mask_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">]]</span>
            <span class="c1"># Merge the channel mapping results for this coarse subsegment</span>
            <span class="c1">#   - which will allow recomputation of the entire channel network</span>
            <span class="c1">#     during pass#3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">][</span><span class="o">~</span><span class="n">merged_mask_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">]]</span> \
                <span class="o">|=</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="o">~</span><span class="n">merged_mask_array</span><span class="p">[</span><span class="n">bounds</span><span class="p">]]</span>
<span class="c1">#             self.mapping_array[bounds] |= data.mapping_array &amp; info.is_channel</span>
            <span class="c1"># Delete this iteration&#39;s raw coarse mask from the active list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">remove_active_mask</span><span class="p">(</span><span class="s1">&#39;raw_segment&#39;</span><span class="p">)</span>
            <span class="c1"># Erase the working instance of data to ensure </span>
            <span class="c1">#   that the next iteration starts fresh</span>
            <span class="k">del</span> <span class="n">data</span>
               
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_switch_back_to_verbose_mode</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">report_progress</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">)</span>
        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">**Pass#2 end**&#39;</span><span class="p">)</span> 
                
    <span class="k">def</span> <span class="nf">pass3</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>   
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pass or stage 3 of HSL mapping.</span>
<span class="sd">        </span>
<span class="sd">        - Filter the HSL results into a smoothed, contourable grid.</span>
<span class="sd">        - Compute filtered terrain aspect and combine with this HSL grid.</span>
<span class="sd">        - Generate a mean HSL(aspect) function and related statistics </span>
<span class="sd">          to determine whether or not there is a N-S bias.</span>
<span class="sd">        &quot;&quot;&quot;</span>     
        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">**Pass#3 begin**&#39;</span><span class="p">)</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset_active_masks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_active_mask</span><span class="p">({</span><span class="s1">&#39;merged_coarse&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_coarse_mask_array</span><span class="p">})</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">()</span>
        <span class="n">bbox</span><span class="p">,</span> <span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span> <span class="o">=</span> <span class="n">get_bbox</span><span class="p">(</span><span class="o">~</span><span class="n">mask_array</span><span class="p">)</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pad_width</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">Info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_xy</span><span class="p">(</span><span class="n">nxb</span><span class="p">,</span><span class="n">nyb</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_thresholds</span><span class="p">(</span><span class="n">segmentation_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fine_segmentation_threshold</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="n">bbox</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="n">pad</span><span class="p">,</span>
                     <span class="n">mapping_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">,</span>
                     <span class="n">mask_array</span>    <span class="o">=</span> <span class="n">mask_array</span><span class="p">,</span>
                     <span class="n">uv_array</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="o">.</span><span class="n">uv_array</span><span class="p">,</span>
                     <span class="n">slc_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">slc_array</span><span class="p">,</span>
                     <span class="n">slt_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">slt_array</span><span class="p">,</span>
                     <span class="n">sla_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">sla_array</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_map_channels_segments</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> 
                                             <span class="n">do_map_channels_from_scratch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                             <span class="n">do_map_segments</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Error occurred during channel mapping&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">slc_array</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">slt_array</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">sla_array</span>
        <span class="c1"># Erase left flank flagging for easier viz of channels</span>
<span class="c1">#         self.mapping_array[(self.mapping_array &amp; info.is_leftflank)&gt;0] \</span>
<span class="c1">#             = self.mapping_array[(self.mapping_array &amp; info.is_leftflank)&gt;0]  \</span>
<span class="c1">#                         ^ info.is_leftflank</span>
        
        <span class="c1"># Revert to working on the whole DTM (ROI), mainly because </span>
        <span class="c1">#   extrapolation (dilation) into masked pixels needs to spread </span>
        <span class="c1">#   as far as needed, which is user-defined and may be quite large</span>
        <span class="c1">#   - thus not worth the trouble to add bboxing complexity here</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_nx</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_ny</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">ny</span><span class="o">+</span><span class="n">pad</span><span class="o">*</span><span class="mi">2</span>
        <span class="n">info</span><span class="o">.</span><span class="n">set_xy</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span> <span class="n">pad</span><span class="p">)</span>
        <span class="c1"># Filter HSL into a contourable, somewhat smooth grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_hsl</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="c1"># Map smoothed terrain aspect aka orientation relative to east from uv array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_aspect</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="c1"># Make 1-byte boolean arrays of selected mapping flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thinchannel_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelhead_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midslope_array</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ridge_array</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thinchannel_array</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_thinchannel</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channelhead_array</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channelhead</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midslope_array</span><span class="p">[</span>   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_midslope</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>    <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ridge_array</span><span class="p">[</span>      <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_ridge</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>       <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># Calculate an empirical HSL(aspect) function and related statistics</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_skip_hsl</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">combine_hsl_aspect</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_stats</span><span class="p">()</span>
<span class="c1">#         self.state.remove_active_mask(&#39;merged_coarse&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span><span class="s1">&#39;**Pass#3 end**&#39;</span><span class="p">)</span> 
                
    <span class="k">def</span> <span class="nf">do_map_channels_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> 
                                 <span class="n">do_map_channels_from_scratch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">do_map_segments</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        TBD.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Use downstream slt,sla pdfs to designate pixels as channels</span>
            <span class="k">if</span> <span class="n">do_map_channels_from_scratch</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">map_channels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="c1"># Join up disconnected channel pixels if they are not too widely spaced</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">connect_channel_pixels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>                
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Skeletonize channel pixels into thin network</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thin_channels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="c1"># Locate upstream ends of thinned channel network &amp; designate as heads</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_channel_heads</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Link downstream from channel heads</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_downchannels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Count downstream from channel heads</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag_downchannels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Stop now if we&#39;re on pass3</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">do_map_segments</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="c1"># Map locations of channel confluences &amp; designate types</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_confluences</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Label channel segments with channel head idxs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_downchannels</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>            
            <span class="c1"># Designate downstream linkages for all hillslope pixels</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_hillslopes</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Label correspondingly upstream hillslope pixels</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment_hillslopes</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Designate as L or R of channel to subsegment hillslope flanks</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">subsegment_flanks</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># Success</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
            <span class="c1"># Failure</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vbackup</span><span class="p">,</span> <span class="s1">&#39;Failed in &quot;do_map_channels_segments&quot;:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
            <span class="k">raise</span>
            <span class="c1"># Redundant</span>
            <span class="k">return</span> <span class="kc">False</span>


    <span class="k">def</span> <span class="nf">_switch_to_quiet_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_switch_back_to_verbose_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbackup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbackup</span>

    <span class="k">def</span> <span class="nf">report_progress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n_segments</span><span class="p">,</span> <span class="n">subsegment</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="p">((</span><span class="n">idx</span><span class="p">)</span><span class="o">/</span><span class="n">n_segments</span><span class="p">)</span><span class="o">*</span><span class="mf">100.0</span>
        <span class="k">if</span> <span class="n">subsegment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0:2.1f}</span><span class="s1">% </span><span class="si">{1:+}</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span><span class="n">subsegment</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vprogress</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{0:2.1f}</span><span class="s1">% &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">progress</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">map_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Channels...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># Designate channel pixels according to dslt pdf analysis</span>
        <span class="n">slt</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">slt_array</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">slc_array</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># HACK slt*2&gt;=slc </span>
        <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[(</span><span class="n">slt</span><span class="o">&gt;=</span><span class="n">info</span><span class="o">.</span><span class="n">channel_threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">slt</span><span class="o">*</span><span class="mi">2</span><span class="o">&gt;=</span><span class="n">slc</span><span class="p">)]</span><span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channel</span>   
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  

    <span class="k">def</span> <span class="nf">connect_channel_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">connect</span><span class="o">.</span><span class="n">connect_channel_pixels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span><span class="n">info</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">thin_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Thinning channels...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
        <span class="n">nxp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="n">mapping_array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span>
        <span class="n">channel_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">channel_array</span><span class="p">[</span>  <span class="p">((</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channel</span><span class="p">)</span><span class="o">==</span><span class="n">info</span><span class="o">.</span><span class="n">is_channel</span><span class="p">)</span>
                      <span class="o">|</span> <span class="p">((</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_interchannel</span><span class="p">)</span><span class="o">==</span><span class="n">info</span><span class="o">.</span><span class="n">is_interchannel</span><span class="p">)</span>
                     <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;skeletonizing...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
        <span class="n">skeleton_array</span> <span class="o">=</span> <span class="n">skeletonize</span><span class="p">(</span><span class="n">medial_axis</span><span class="p">(</span><span class="n">channel_array</span><span class="p">))</span>
        <span class="n">mapping_array</span><span class="p">[</span><span class="n">skeleton_array</span><span class="p">]</span> <span class="o">|=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_thinchannel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  

    <span class="k">def</span> <span class="nf">map_channel_heads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">channelheads</span><span class="o">.</span><span class="n">map_channel_heads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="c1"># HACK - this step used to be necessary - can it really be dropped?</span>
<span class="c1">#         channelheads.prune_channel_heads(self.cl_state, info, data, </span>
<span class="c1">#                                          self.verbose)</span>
        
    <span class="k">def</span> <span class="nf">count_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="n">data</span><span class="o">.</span><span class="n">count_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">link_array</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">countlink</span><span class="o">.</span><span class="n">count_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">flag_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">countlink</span><span class="o">.</span><span class="n">flag_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">label_confluences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="o">.</span><span class="n">label_confluences</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="ow">not</span> <span class="n">countlink</span><span class="o">.</span><span class="n">flag_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="ow">not</span> <span class="n">countlink</span><span class="o">.</span><span class="n">flag_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> 
                                    <span class="n">do_reset_count</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> \
           <span class="ow">or</span> <span class="ow">not</span> <span class="n">countlink</span><span class="o">.</span><span class="n">flag_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">,</span> 
                                    <span class="n">do_reset_count</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Three passes to try to eliminate all &#39;parasite&#39; streamlets</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
    <span class="k">def</span> <span class="nf">segment_downchannels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="n">data</span><span class="o">.</span><span class="n">label_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">segment_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Save the channel-only segment labeling for now; also convert to unsigned</span>
        <span class="n">data</span><span class="o">.</span><span class="n">channel_label_array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
        
    <span class="k">def</span> <span class="nf">link_hillslopes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hillslopes</span><span class="o">.</span><span class="n">link_hillslopes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">segment_hillslopes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">segment</span><span class="o">.</span><span class="n">segment_hillslopes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">subsegment_flanks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Channel edges first, and then flanks</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">segment</span><span class="o">.</span><span class="n">subsegment_flanks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">):</span>
            <span class="c1"># Failure</span>
            <span class="k">return</span> <span class="kc">False</span>
<span class="c1">#         data.label_array = data.label_array.astype(dtype=np.int32)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> \
            <span class="o">=</span> <span class="o">-</span><span class="p">(</span>  <span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">info</span><span class="o">.</span><span class="n">left_flank_addition</span> <span class="p">)</span>
        <span class="c1"># Flag all went well</span>
        <span class="k">return</span> <span class="kc">True</span>
        
    <span class="c1"># Shift to pass#1</span>
    
    <span class="k">def</span> <span class="nf">map_midslopes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Midslopes...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
        <span class="n">dsla</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sla_array</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">usla</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sla_array</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mask_array</span>
        <span class="n">nxp</span>  <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span>  <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="n">midslope_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
<span class="c1">#         pdebug(&#39;self.midslope_filter_sigma&#39;, self.midslope_filter_sigma)</span>
        <span class="n">midslope_array</span><span class="p">[</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span>
            <span class="n">gaussian_filter</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dsla</span><span class="p">,</span><span class="n">usla</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">midslope_filter_sigma</span><span class="p">))</span>
                             <span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">midslope_threshold</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">midslope_array</span><span class="p">)]</span> <span class="o">|=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_midslope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  

    <span class="k">def</span> <span class="nf">map_ridges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Ridges...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
        <span class="n">dsla</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sla_array</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">usla</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">sla_array</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mask_array</span>
        <span class="n">nxp</span>  <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span>  <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="n">ridge_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">fat_ridge_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">ridge_array</span><span class="p">[</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span>
            <span class="n">gaussian_filter</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dsla</span><span class="p">,</span><span class="n">usla</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ridge_filter_sigma</span><span class="p">))</span>
                             <span class="o">&lt;=</span> <span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ridge_threshold</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">dilation_structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">binary_dilation</span><span class="p">(</span><span class="n">ridge_array</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">dilation_structure</span><span class="p">,</span> 
                        <span class="n">iterations</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">fat_ridge_array</span><span class="p">)</span>
        <span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">fat_ridge_array</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">fat_ridge_array</span><span class="p">)</span>
<span class="c1">#         dilation_structure = generate_binary_structure(2, 2)</span>
<span class="c1">#         binary_dilation(skeletonize(fat_ridge_array), </span>
<span class="c1">#                         structure=dilation_structure, </span>
<span class="c1">#                         iterations=5, output=ridge_array)</span>
<span class="c1">#         data.mapping_array[ridge_array] |= info.is_ridge</span>
<span class="c1">#         data.mapping_array[fat_ridge_array] |= info.is_ridge</span>
        <span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span><span class="p">[</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">fat_ridge_array</span><span class="p">)]</span> <span class="o">|=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_ridge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  

    <span class="k">def</span> <span class="nf">select_subsegments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">do_restrict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Selecting subsegments for HSL mapping...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  
        <span class="k">if</span> <span class="n">do_restrict</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_measure_hsl_from_ridges</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_ridge</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;measuring from ridges...&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flag</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">is_midslope</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;measuring from midslopes...&#39;</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">subsegment_label_array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">[</span>
        <span class="c1">#             np.logical_and((data.mapping_array &amp; flag)&gt;0,~data.mask_array))</span>
                         <span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask_array</span><span class="p">)</span>
                                            <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">subsegment_label_array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">[(</span><span class="o">~</span><span class="n">data</span><span class="o">.</span><span class="n">mask_array</span><span class="p">)</span>
                                        <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">unique_labels</span>         <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">subsegment_label_array</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">selected_subsegments_array</span> <span class="o">=</span> <span class="n">unique_labels</span><span class="p">[</span><span class="n">unique_labels</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_subsegments</span>    <span class="o">=</span> <span class="n">unique_labels</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;selected </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_subsegments</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;...done&#39;</span><span class="p">)</span>  
                                
    <span class="k">def</span> <span class="nf">fmm_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">data</span><span class="o">.</span><span class="n">subsegment_hsl_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">selected_subsegments_array</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">subsegment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">selected_subsegments_array</span><span class="p">):</span>
            <span class="n">phi_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">phi_mod</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">mask</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="n">phi_bool</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">subsegment</span><span class="p">)]</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">n_phi_pixels</span> <span class="o">=</span> <span class="n">phi_bool</span><span class="p">[</span><span class="n">phi_bool</span><span class="o">==</span><span class="kc">True</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="n">n_erosions</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">n_erosions</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">erosion_structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">phi_bool_eroded</span> <span class="o">=</span> <span class="n">binary_erosion</span><span class="p">(</span><span class="n">phi_bool</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">erosion_structure</span><span class="p">,</span> 
                                                           <span class="n">iterations</span><span class="o">=</span><span class="n">n_erosions</span><span class="p">)</span>
                <span class="n">phi_bool</span> <span class="o">=</span> <span class="n">phi_bool_eroded</span>
            <span class="n">n_dilations</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n_dilations</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">dilation_structure</span> <span class="o">=</span> <span class="n">generate_binary_structure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">phi_bool_dilated</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">phi_bool</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">dilation_structure</span><span class="p">,</span> 
                                                   <span class="n">iterations</span><span class="o">=</span><span class="n">n_dilations</span><span class="p">)</span>
                <span class="n">phi_bool</span> <span class="o">=</span> <span class="n">phi_bool_dilated</span>
            <span class="n">phi_mod</span> <span class="o">=</span> <span class="n">phi_bool</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">phi_mod</span><span class="p">[((</span><span class="n">data</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_thinchannel</span><span class="p">)</span><span class="o">==</span><span class="n">info</span><span class="o">.</span><span class="n">is_thinchannel</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="p">)</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">subsegment</span><span class="p">))]</span><span class="o">=-</span><span class="mi">1</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">phi_bool_dilated</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">phi_mod</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">phi_mod</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

            <span class="n">n_channel_pixels</span> <span class="o">=</span> <span class="n">phi_mod</span><span class="p">[</span><span class="n">phi_mod</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="n">n_channel_pixels</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ratio_phi_channel</span> <span class="o">=</span> <span class="n">n_phi_pixels</span><span class="o">/</span><span class="n">n_channel_pixels</span>

            <span class="k">try</span><span class="p">:</span>   
                <span class="n">distance</span> <span class="o">=</span> <span class="n">skfmm</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">phi_mod</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span><span class="p">)</span>
<span class="c1">#                 hsl = np.max(distance)</span>
                <span class="n">hsl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span>
                <span class="k">if</span> <span class="n">ratio_phi_channel</span><span class="o">&gt;</span><span class="mf">4.0</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">subsegment_hsl_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsl</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            
<span class="c1">#             self.plot.plot_gridded_data(phi_mod,&#39;jet&#39;, #&#39;randomized&#39;,</span>
<span class="c1">#                                         do_colorbar=True, #mask_array=mask,</span>
<span class="c1">#                                         do_balance_cmap=False, do_shaded_relief=False,</span>
<span class="c1">#                                         extent=[0,phi_mod.shape[0],0,phi_mod.shape[1]],</span>
<span class="c1">#                                         window_size_factor=2)</span>
<span class="c1">#             self.plot.plot_gridded_data(distance,&#39;jet&#39;, #mask_array=mask,</span>
<span class="c1">#                                         do_colorbar=True,</span>
<span class="c1">#                                         do_balance_cmap=False, do_shaded_relief=False,</span>
<span class="c1">#                                         extent=[0,distance.shape[0],0,distance.shape[1]],</span>
<span class="c1">#                                         window_size_factor=2)</span>
<span class="c1">#         pdebug(data.subsegment_label_array.size,data.subsegment_hsl_array.size)</span>
        <span class="n">hsl_array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">subsegment_hsl_array</span>
        
<span class="c1">#         hsl_array = hsl_array[hsl_array&gt;0.0]</span>
        <span class="k">if</span> <span class="n">hsl_array</span><span class="p">[</span><span class="n">hsl_array</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">fmm_mean_hsl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">hsl_array</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">])</span>
<span class="c1">#             pdebug(&#39;FMM  HSL = {:.1f}m&#39;.format(fmm_mean_hsl))</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
      
    <span class="k">def</span> <span class="nf">measure_hsl_fmm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Measuring hillslope lengths using eikonal distance...&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">subsegment_label_array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">selected_subsegments_array</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmm_lengths</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;...done&#39;</span><span class="p">)</span>  
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">measure_hsl_traced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Measuring hillslope lengths...&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">subsegment_hsl_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">subsegment_label_array</span><span class="p">,</span>
                                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lengths</span><span class="o">.</span><span class="n">hsl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cl_state</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_measure_hsl_from_ridges</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;...done&#39;</span><span class="p">)</span>  
        <span class="k">return</span> <span class="kc">True</span>
        
    <span class="k">def</span> <span class="nf">parse_hsl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Parsing hillslope lengths...&#39;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">subsegment_hsl_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;fine&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> 
                                                <span class="p">(</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)]))</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;fine&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">subsegment_label_array</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">subsegment_hsl_array</span>
<span class="c1">#         pdebug(df)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">fine</span><span class="o">!=</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stats_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">selected_subsegments_array</span><span class="p">,</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;fine&#39;</span><span class="p">])</span>
            <span class="n">stats_list</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span><span class="s1">&#39;count&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;mean [m]&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">,</span><span class="s1">&#39;stddev [m]&#39;</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">stats_list</span><span class="p">:</span>
                <span class="n">stats_df</span> <span class="o">=</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;fine&#39;</span><span class="p">),</span><span class="n">stat</span><span class="p">[</span><span class="mi">0</span><span class="p">])(),</span>
                                          <span class="n">on</span><span class="o">=</span><span class="s1">&#39;fine&#39;</span><span class="p">)</span>
                <span class="n">stats_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;length&#39;</span><span class="p">:</span><span class="n">stat</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Problem constructing HSL stats dataframe&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">stats_df</span><span class="p">[</span><span class="s1">&#39;coarse&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">coarse_label</span>
        <span class="n">stats_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">&#39;fine&#39;</span><span class="p">,</span><span class="s1">&#39;coarse&#39;</span><span class="p">],</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span> <span class="o">=</span> <span class="n">stats_df</span>
<span class="c1">#         pdebug(stats_df)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;...done&#39;</span><span class="p">)</span>  
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">remap_hsl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_hsl_averaging_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Remapping hillslope lengths onto grid...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_hsl_averaging_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_hsl_averaging_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hsl_averaging_threshold</span>
        <span class="n">stats_df</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">hsl_stats_df</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="k">try</span><span class="p">:</span>   
            <span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">n_hsl_averaging_threshold</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="o">==</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;mean [m]&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">label_array</span><span class="o">==</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Problem with HSL stats dataframe&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">stats_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Unable to map HSL here - skipping&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">hsl_nonan</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">hsl_array</span><span class="p">)]</span>
        <span class="n">hsl_nonan</span> <span class="o">=</span> <span class="n">hsl_nonan</span><span class="p">[</span><span class="n">hsl_nonan</span><span class="o">&gt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_averaging_threshold</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">hsl_nonan</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;No HSL values in dataframe - skipping&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">data</span><span class="o">.</span><span class="n">trace_mean_hsl</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl_nonan</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;...done&#39;</span><span class="p">)</span>  
        <span class="k">return</span> <span class="kc">True</span>


    <span class="k">def</span> <span class="nf">map_hsl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Mapping hillslope lengths from </span><span class="si">{}</span><span class="s1">...&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">(</span><span class="s1">&#39;ridges&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_measure_hsl_from_ridges</span> <span class="k">else</span> <span class="s1">&#39;midslopes&#39;</span><span class="p">)),</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1"># Make a working copy of HSL and find limits</span>
        <span class="n">hsl</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_array</span>
        <span class="n">hsl_min</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">hsl</span><span class="p">)</span>
        <span class="n">hsl_max</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hsl</span><span class="p">)</span>
        <span class="c1"># Convert to unsigned 16bit so HSL can be filtered using skimage tools</span>
        <span class="n">hsl_clipped</span> <span class="o">=</span> <span class="p">(</span><span class="mi">65535</span><span class="o">*</span><span class="p">(</span><span class="n">hsl</span><span class="o">-</span><span class="n">hsl_min</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">hsl_max</span><span class="o">-</span><span class="n">hsl_min</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
        <span class="c1"># Get the current mask</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">()</span>
        <span class="c1"># BUG ? perhaps we shouldn&#39;t slice off padding in hsl_smoothed?</span>
        <span class="n">pad</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pad_width</span>
        <span class="n">pslice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>
        <span class="c1"># Sizes of dilation and mean filters in pixels</span>
        <span class="n">dfw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_dilation_width</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span><span class="p">)</span>
        <span class="n">mdr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_radius</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">roi_pixel_size</span><span class="p">)</span>
        <span class="c1"># Make a mean disk filter </span>
        <span class="n">mean_disk</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="n">mdr</span><span class="p">)</span>
        <span class="c1"># Spread HSL values into masked pixels by dilation</span>
        <span class="c1">#   - when contouring, this spreading has the effect of avoiding</span>
        <span class="c1">#     nasty mask-boundary edge effects, i.e., masked areas are treated</span>
        <span class="c1">#     as zeros and force dense erroneous contours to arise at boundaries</span>
        <span class="c1"># Also mean filter to make for reasonably smooth contouring. </span>
        <span class="c1">#    - plus helps to skip over skinny isolated HSL strips with</span>
        <span class="c1">#      somewhat bogus extreme values.</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dfw</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">hsl_dilated</span> <span class="o">=</span> <span class="n">hsl_clipped</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;dilation with </span><span class="si">{0}</span><span class="s1">m (</span><span class="si">{1}</span><span class="s1">-pixel) width filter...&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_dilation_width</span><span class="p">,</span><span class="n">dfw</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">hsl_dilated</span> <span class="o">=</span> <span class="n">grey_dilation</span><span class="p">(</span><span class="n">hsl_clipped</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">dfw</span><span class="p">,</span><span class="n">dfw</span><span class="p">))</span>
                <span class="n">hsl_dilated</span><span class="p">[</span><span class="o">~</span><span class="n">mask_array</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsl_clipped</span><span class="p">[</span><span class="o">~</span><span class="n">mask_array</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;mean filtering with </span><span class="si">{0}</span><span class="s1">m (</span><span class="si">{1}</span><span class="s1">-pixel) diameter disk...&#39;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_radius</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">mdr</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span> 
            <span class="n">hsl_mean</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">hsl_dilated</span><span class="p">,</span><span class="n">mean_disk</span><span class="p">)</span>
        <span class="c1"># Rescale filtered HSL back into floats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_smoothed_array</span> \
            <span class="o">=</span> <span class="p">((</span><span class="n">hsl_mean</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span><span class="o">/</span><span class="mi">65535</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">hsl_max</span><span class="o">-</span><span class="n">hsl_min</span><span class="p">)</span><span class="o">+</span><span class="n">hsl_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  
        
    <span class="k">def</span> <span class="nf">map_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Computing hillslope aspect with median filter radii&#39;</span>
                   <span class="o">+</span><span class="s1">&#39; </span><span class="si">{0}</span><span class="s1">m (slope), </span><span class="si">{1}</span><span class="s1">m (uv)...&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aspect_median_filter_radius</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">uv_median_radius</span><span class="p">),</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">nxp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">nx_padded</span>
        <span class="n">nyp</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">ny_padded</span>
        <span class="n">slope_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspect_slope_threshold</span>
        <span class="c1"># Copy the slope grid because we&#39;re going to monkey with it</span>
        <span class="n">slope_array</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="o">.</span><span class="n">slope_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">uv_array</span>        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preprocess</span><span class="o">.</span><span class="n">uv_array</span>
        <span class="n">mask_array</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nxp</span><span class="p">,</span><span class="n">nyp</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">slope_array</span><span class="p">[((</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channel</span><span class="p">)</span><span class="o">==</span><span class="n">info</span><span class="o">.</span><span class="n">is_channel</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">median_radius</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspect_median_filter_radius</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pixel_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_aspect_median_filtering</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">slope_array</span><span class="p">)</span><span class="o">/</span><span class="mf">255.0</span>
            <span class="n">slope_array</span> <span class="o">=</span> <span class="n">sf</span><span class="o">*</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">slope_array</span><span class="o">/</span><span class="n">sf</span><span class="p">),</span><span class="n">disk</span><span class="p">(</span><span class="n">median_radius</span><span class="p">))</span>

        <span class="n">median_disk</span> <span class="o">=</span> <span class="n">disk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uv_median_radius</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pixel_size</span><span class="p">)</span>
        <span class="n">sf</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">/</span><span class="mf">255.0</span>
        <span class="n">uvx_array</span> <span class="o">=</span> <span class="n">sf</span><span class="o">*</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">((</span><span class="n">uv_array</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">sf</span><span class="p">),</span><span class="n">median_disk</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span>
        <span class="n">uvy_array</span> <span class="o">=</span> <span class="n">sf</span><span class="o">*</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">((</span><span class="n">uv_array</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="n">sf</span><span class="p">),</span><span class="n">median_disk</span><span class="p">)</span><span class="o">-</span><span class="mf">1.0</span>
        <span class="n">mask_array</span><span class="p">[</span>  <span class="p">(</span><span class="n">slope_array</span><span class="o">&lt;</span><span class="n">slope_threshold</span><span class="p">)</span>
                   <span class="o">|</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping_array</span> <span class="o">&amp;</span> <span class="n">info</span><span class="o">.</span><span class="n">is_channel</span><span class="p">)</span><span class="o">==</span><span class="n">info</span><span class="o">.</span><span class="n">is_channel</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="c1">#         self.aspect_array = np.ma.masked_array( np.arctan2(uvy_array,uvx_array), </span>
<span class="c1">#                                                 mask=mask_array )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aspect_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">uvy_array</span><span class="p">,</span><span class="n">uvx_array</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aspect_mask_array</span> <span class="o">=</span> <span class="n">mask_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  
                                                         
    <span class="k">def</span> <span class="nf">combine_hsl_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hsl_averaging_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Computing hillslope length-aspect function...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        
        <span class="c1"># Default to e.g. aspect bins 6° wide</span>
        <span class="k">if</span> <span class="n">n_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_aspect_bins</span>
        <span class="c1"># HSL value below hsl_averaging_threshold will be ignored</span>
        <span class="k">if</span> <span class="n">hsl_averaging_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hsl_averaging_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_averaging_threshold</span>
        <span class="c1"># Shorthand</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodata</span><span class="o">.</span><span class="n">pad_width</span>
        <span class="n">pslice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span><span class="n">pad</span><span class="p">:</span><span class="o">-</span><span class="n">pad</span><span class="p">]</span>
        <span class="c1"># Use basic masks plus the merged coarse-subsegmentation mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">reset_active_masks</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">add_active_mask</span><span class="p">({</span><span class="s1">&#39;merged_coarse&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_coarse_mask_array</span><span class="p">})</span>
        <span class="c1"># Also exclude any np.ma masked pixels in self.aspect_array</span>
<span class="c1">#         mask_array = self.state.merge_active_masks()[pslice] \</span>
<span class="c1">#                    | self.aspect_array[pslice].mask</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">merge_active_masks</span><span class="p">()[</span><span class="n">pslice</span><span class="p">]</span> \
                   <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspect_mask_array</span><span class="p">[</span><span class="n">pslice</span><span class="p">]</span>
        <span class="c1"># Fetch non-masked aspect and HSL values</span>
        <span class="n">aspect_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspect_array</span><span class="p">[</span><span class="n">pslice</span><span class="p">][</span><span class="o">~</span><span class="n">mask_array</span><span class="p">]</span>
        <span class="n">hsl_array</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_smoothed_array</span><span class="p">[</span><span class="n">pslice</span><span class="p">][</span><span class="o">~</span><span class="n">mask_array</span><span class="p">]</span>
        
        <span class="c1"># HACK!!!!</span>
        <span class="k">if</span> <span class="n">hsl_array</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">0</span><span class="p">,):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;here&#39;</span><span class="p">)</span>
            <span class="n">aspect_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aspect_array</span><span class="p">[</span><span class="n">pslice</span><span class="p">]</span>
            <span class="n">hsl_array</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_smoothed_array</span><span class="p">[</span><span class="n">pslice</span><span class="p">]</span>
            
        <span class="c1"># Convert aspect to degrees</span>
        <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">aspect_array</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">aspect_array</span><span class="p">)</span>
        <span class="c1"># Combine into HSL(aspect) array</span>
        <span class="c1"># Exclude &quot;negligibly&quot; small HSL values aka near zero mismeasurements</span>
        <span class="n">hsl_aspect_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">hsl_array</span><span class="p">[</span><span class="n">hsl_array</span><span class="o">&gt;=</span><span class="n">hsl_averaging_threshold</span><span class="p">],</span>
                                      <span class="n">aspect_array</span><span class="p">[</span><span class="n">hsl_array</span><span class="o">&gt;=</span><span class="n">hsl_averaging_threshold</span><span class="p">]),</span> 
                                      <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Convert into a pandas dataframe for easier processing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;hsl&#39;</span><span class="p">,</span><span class="s1">&#39;aspect&#39;</span><span class="p">],</span>
                                <span class="n">data</span><span class="o">=</span><span class="n">hsl_aspect_array</span><span class="p">[</span><span class="n">hsl_aspect_array</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()])</span>
        <span class="c1"># Likely 3° bin half-width and 6° bin width</span>
        <span class="n">half_bin_width</span> <span class="o">=</span> <span class="mi">180</span><span class="o">/</span><span class="n">n_bins</span>
        <span class="n">bin_width</span> <span class="o">=</span> <span class="n">half_bin_width</span><span class="o">*</span><span class="mi">2</span>
        <span class="c1"># Vector of all bin edges, e.g., -183°,-177°,...,+177°,+183°</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">+</span><span class="mi">180</span><span class="o">+</span><span class="n">bin_width</span><span class="p">,</span><span class="n">n_bins</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">half_bin_width</span>
        <span class="c1"># Group HSL values using degree-valued bin edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_df</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_df</span><span class="p">[</span><span class="s1">&#39;aspect&#39;</span><span class="p">],</span> <span class="n">bins</span><span class="p">)</span>
        <span class="c1"># Average HSL values in each group</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_averages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;groups&#39;</span><span class="p">)[</span><span class="s1">&#39;hsl&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">hsl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_averages</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Force HSL(±180°) values to match</span>
        <span class="n">west_hsl</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">hsl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">hsl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">west_hsl</span>
        <span class="n">hsl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">west_hsl</span>
        <span class="c1"># Convert bins to radians</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">half_bin_width</span><span class="p">)</span>
        <span class="c1"># Combine into average-HSL(aspect) array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_averages_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">hsl</span><span class="p">,</span><span class="n">bins</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  
        
    <span class="k">def</span> <span class="nf">hsl_aspect_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hsl_averaging_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Computing hillslope length-aspect statistics...&#39;</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># Shorthand</span>
        <span class="n">haa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_averages_array</span>
        <span class="n">hsl</span> <span class="o">=</span> <span class="n">haa</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">haa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">asp</span> <span class="o">=</span> <span class="n">haa</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">haa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Split into N and S HSL arrays</span>
        <span class="n">hsl_south_array</span> <span class="o">=</span> <span class="n">hsl</span><span class="p">[</span><span class="n">asp</span><span class="o">&lt;=</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="n">hsl_north_array</span> <span class="o">=</span> <span class="n">hsl</span><span class="p">[</span><span class="n">asp</span><span class="o">&gt;=</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="c1"># If we have HSL() at +180° and -180°, don&#39;t repeat in mean</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">asp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">asp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl</span><span class="p">)</span>
        <span class="c1"># Mean HSL north and south</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_south</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl_south_array</span><span class="p">)</span> <span class="k">if</span> <span class="n">hsl_south_array</span><span class="o">!=</span><span class="p">[]</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_north</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl_north_array</span><span class="p">)</span> <span class="k">if</span> <span class="n">hsl_north_array</span><span class="o">!=</span><span class="p">[]</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># Disparity between north and south means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_north</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_south</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean</span>
        <span class="c1"># Overall HSL standard deviation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_stddev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">hsl</span><span class="p">)</span>
        <span class="c1"># Split HSL(aspect) into n_hsl_split groups e.g. 4 to compute std devn</span>
        <span class="n">hsl_split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">hsl_split</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hsl_split</span><span class="p">)])</span>
                              <span class="k">if</span> <span class="n">hsl_split</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hsl_split</span><span class="p">)]</span><span class="o">!=</span><span class="p">[]</span> <span class="k">else</span> <span class="mf">0.0</span>
                              <span class="k">for</span> <span class="n">hsl_split</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">haa</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">n_hsl_split</span><span class="p">)</span>  <span class="p">])</span>
        <span class="c1"># Compute mean split std devn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl_split</span><span class="p">)</span> <span class="k">if</span> <span class="n">hsl_split</span><span class="o">!=</span><span class="p">[]</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="c1"># Normalize split std devn by mean = coefficient of variation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev_normed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean</span>
        <span class="c1"># Eliminate NaNs from hsl_aspect_averages_array</span>
        <span class="n">haa</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">haa</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])]</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="c1"># Convert HSL(aspect) vectors into complex numbers</span>
        <span class="n">hsl_complex_vec_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rect</span><span class="p">(</span><span class="n">ha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">ha</span> <span class="ow">in</span> <span class="n">haa</span><span class="p">]))</span>
        <span class="n">hsl_complex_vec_array</span> <span class="o">=</span> <span class="n">hsl_complex_vec_array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">hsl_complex_vec_array</span><span class="p">)]</span>
        <span class="c1"># Compute the mean complex HSL vector</span>
        <span class="n">hsl_mean_complex_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">hsl_complex_vec_array</span><span class="p">)</span>
        <span class="c1"># Convert the mean complex HSL vector back into a polar vector HSL,aspect</span>
        <span class="n">mhsl</span> <span class="o">=</span> <span class="n">polar</span><span class="p">(</span><span class="n">hsl_mean_complex_vector</span><span class="p">)</span>
<span class="c1">#         pdebug()</span>
<span class="c1">#         pdebug(hsl_complex_vec_array)</span>
<span class="c1">#         pdebug(&#39;hsl_mean_complex_vector&#39;,hsl_mean_complex_vector)</span>
<span class="c1">#         pdebug(&#39;mhsl&#39;,mhsl)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_magnitude</span> <span class="o">=</span> <span class="n">mhsl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_azimuth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">mhsl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Calculate a confidence measure for any N-S disparity</span>
        <span class="c1">#   - effectively a signal:noise ratio </span>
        <span class="c1">#     defined as reciprocal coefficient of variation</span>
        <span class="c1">#         =    (N HSL_mean - S HSL_mean)/(mean split HSL std devn)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_confidence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev</span>
        
        <span class="c1"># N-facing v S-facing stats</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_aspect_df</span>
        <span class="n">hsl_n</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">hsl</span><span class="p">[(</span><span class="n">df</span><span class="o">.</span><span class="n">aspect</span><span class="o">&gt;+</span><span class="mi">45</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">aspect</span><span class="o">&lt;+</span><span class="mi">135</span><span class="p">)]</span>
        <span class="n">hsl_s</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">hsl</span><span class="p">[(</span><span class="n">df</span><span class="o">.</span><span class="n">aspect</span><span class="o">&lt;-</span><span class="mi">45</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">aspect</span><span class="o">&gt;-</span><span class="mi">135</span><span class="p">)]</span>
        <span class="n">uhsl_n</span> <span class="o">=</span> <span class="n">hsl_n</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">uhsl_s</span> <span class="o">=</span> <span class="n">hsl_s</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="n">uhsl_n</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="n">uhsl_s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">nn</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">ns</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks_nm</span>       <span class="o">=</span> <span class="n">nn</span><span class="o">*</span><span class="n">ns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks_nmfactor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">nn</span><span class="o">+</span><span class="n">ns</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">nn</span><span class="o">*</span><span class="n">ns</span><span class="p">))</span>
            <span class="n">ks</span>    <span class="o">=</span> <span class="n">ks_2samp</span><span class="p">(</span><span class="n">uhsl_n</span><span class="p">,</span><span class="n">uhsl_s</span><span class="p">)</span>
            <span class="n">mw</span>    <span class="o">=</span> <span class="n">mannwhitneyu</span><span class="p">(</span><span class="n">uhsl_n</span><span class="p">,</span><span class="n">uhsl_s</span><span class="p">)</span>
            <span class="n">rs</span>    <span class="o">=</span> <span class="n">ranksums</span><span class="p">(</span><span class="n">uhsl_n</span><span class="p">,</span><span class="n">uhsl_s</span><span class="p">)</span>
            <span class="n">ttest</span> <span class="o">=</span> <span class="n">ttest_ind</span><span class="p">(</span><span class="n">uhsl_n</span><span class="p">,</span><span class="n">uhsl_s</span><span class="p">,</span> <span class="n">equal_var</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">welch</span> <span class="o">=</span> <span class="n">ttest_ind</span><span class="p">(</span><span class="n">uhsl_n</span><span class="p">,</span><span class="n">uhsl_s</span><span class="p">,</span> <span class="n">equal_var</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks</span>          <span class="o">=</span> <span class="p">(</span><span class="n">ks</span><span class="o">.</span><span class="n">statistic</span><span class="p">,</span> <span class="n">ks</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ttest</span>       <span class="o">=</span> <span class="p">(</span><span class="n">ttest</span><span class="o">.</span><span class="n">statistic</span><span class="p">,</span> <span class="n">ttest</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_mannwhitney</span> <span class="o">=</span> <span class="p">(</span><span class="n">mw</span><span class="o">.</span><span class="n">statistic</span><span class="o">/</span><span class="p">(</span><span class="n">nn</span><span class="o">*</span><span class="n">ns</span><span class="p">),</span> <span class="n">mw</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ranksum</span>     <span class="o">=</span> <span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">statistic</span><span class="p">,</span> <span class="n">rs</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_welch</span>       <span class="o">=</span> <span class="p">(</span><span class="n">welch</span><span class="o">.</span><span class="n">statistic</span><span class="p">,</span> <span class="n">welch</span><span class="o">.</span><span class="n">pvalue</span><span class="p">)</span>
            
            <span class="c1"># Compute q-q and p-p curves</span>
            <span class="c1"># Ranges</span>
            <span class="n">hsl_n_min</span>  <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">hsl_n</span><span class="p">)</span>
            <span class="n">hsl_s_min</span>  <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">hsl_s</span><span class="p">)</span>
            <span class="n">hsl_ns_min</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsl_n_min</span><span class="o">+</span><span class="n">hsl_s_min</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="n">hsl_n_max</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">hsl_n</span><span class="p">)</span>
            <span class="n">hsl_s_max</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">hsl_s</span><span class="p">)</span>
            <span class="n">hsl_ns_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">hsl_n_max</span><span class="o">+</span><span class="n">hsl_s_max</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="c1"># Simple vector along cdf axis in %</span>
            <span class="n">percents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
            <span class="c1"># HSL percentiles for each such cdf %: north</span>
            <span class="n">ptile_hsl_n</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">hsl_n</span><span class="p">,</span> <span class="n">percents</span><span class="p">)</span>
            <span class="c1"># HSL percentiles for each such cdf %: south</span>
            <span class="n">ptile_hsl_s</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">hsl_s</span><span class="p">,</span> <span class="n">percents</span><span class="p">)</span>
            <span class="c1"># HSL percentiles for each such cdf %: north+south, ie, diagonal axis            </span>
            <span class="n">ptile_hsl_ns</span>  <span class="o">=</span> <span class="p">(</span><span class="n">ptile_hsl_n</span><span class="o">+</span><span class="n">ptile_hsl_s</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
            <span class="c1"># Interpolating functions for HSL percentiles as fn of diagonal distance</span>
            <span class="n">ptile_hsl_n_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ptile_hsl_ns</span><span class="p">,</span><span class="n">ptile_hsl_n</span><span class="p">)</span>
            <span class="n">ptile_hsl_s_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ptile_hsl_ns</span><span class="p">,</span><span class="n">ptile_hsl_s</span><span class="p">)</span>
            <span class="c1"># Interpolating functions for HSL N &amp; S cdfs</span>
            <span class="n">f_hsl_n_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ptile_hsl_n</span><span class="p">,</span><span class="n">percents</span><span class="p">)</span>
            <span class="n">f_hsl_s_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">ptile_hsl_s</span><span class="p">,</span><span class="n">percents</span><span class="p">)</span>
            <span class="c1"># Resample the cdfs at more regular intervals</span>
            <span class="c1">#   - from both directions, ie, N from S = y(x) and S from N = x(y)</span>
            <span class="n">f_hsl_s_from_n</span> <span class="o">=</span> <span class="n">f_hsl_s_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ptile_hsl_n</span><span class="p">,</span><span class="n">hsl_s_min</span><span class="p">,</span><span class="n">hsl_s_max</span><span class="p">))</span>
            <span class="n">f_hsl_n_from_s</span> <span class="o">=</span> <span class="n">f_hsl_n_interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ptile_hsl_s</span><span class="p">,</span><span class="n">hsl_n_min</span><span class="p">,</span><span class="n">hsl_n_max</span><span class="p">))</span>
            <span class="c1"># Reampling vector for percentiles</span>
            <span class="n">hsls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">hsl_ns_min</span><span class="p">,</span><span class="n">hsl_ns_max</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
            <span class="c1"># Compute the Q-Q curve for HSL N vs S         </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_qq_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">ptile_hsl_s_interp</span><span class="p">(</span><span class="n">hsls</span><span class="p">),</span>
                                              <span class="n">ptile_hsl_n_interp</span><span class="p">(</span><span class="n">hsls</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># Combine N,S cdf curves, </span>
            <span class="c1">#  - with fx = x plus x(y)</span>
            <span class="c1">#  - and  fy = y(x) plus y</span>
            <span class="c1"># This step is needed because the cdfs only (likely) partially overlap</span>
            <span class="c1">#   such that the values of the y=N cdf beyond the range of the x=S cdf</span>
            <span class="c1">#   must be included, at constant x=min/max(S cdf), and vice versa</span>
            <span class="c1"># The resulting sequence of points must be sorted later on       </span>
            <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">percents</span><span class="p">,</span> <span class="n">f_hsl_n_from_s</span><span class="p">)</span> <span class="p">)</span>
            <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">f_hsl_s_from_n</span><span class="p">,</span> <span class="n">percents</span><span class="p">)</span> <span class="p">)</span>
            <span class="c1"># Make a corresponding sequence of points along the diagonal x=y axis</span>
            <span class="n">fm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_hsl_s_from_n</span><span class="o">+</span><span class="n">percents</span><span class="p">,</span><span class="n">percents</span><span class="o">+</span><span class="n">f_hsl_n_from_s</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
            <span class="c1"># Blend into a single array</span>
            <span class="n">fxym</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">fx</span><span class="p">,</span><span class="n">fy</span><span class="p">,</span><span class="n">fm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Finally sort so that the points are all in incremental order</span>
            <span class="n">fxym</span> <span class="o">=</span> <span class="n">fxym</span><span class="p">[</span><span class="n">fxym</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># Interpolating functions for N,S cdfs along diagonal axis</span>
            <span class="n">fxm_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">fxym</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fxym</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">fym_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">fxym</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fxym</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">fmm_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">fxym</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">fxym</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="c1"># Resample N,S cdfs along the diagonal axis</span>
            <span class="n">fxm</span> <span class="o">=</span> <span class="n">fxm_interp</span><span class="p">(</span><span class="n">percents</span><span class="p">)</span>
            <span class="n">fym</span> <span class="o">=</span> <span class="n">fym_interp</span><span class="p">(</span><span class="n">percents</span><span class="p">)</span>
            <span class="n">fmm</span> <span class="o">=</span> <span class="n">fmm_interp</span><span class="p">(</span><span class="n">percents</span><span class="p">)</span>
            <span class="c1"># Build the P-P curve</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_pp_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span> <span class="p">(</span><span class="n">percents</span><span class="p">,</span><span class="n">fxm</span><span class="p">,</span><span class="n">fym</span><span class="p">,</span><span class="n">fmm</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># Compute a K-S-like statistic that measures the disparity between</span>
            <span class="c1">#   the two distributions: </span>
            <span class="c1">#   - where 0=&gt;N-S equal, +1=&gt;100% N longer HSL,  -1=&gt;100% S longer HSL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_pp_diff</span> <span class="o">=</span> <span class="p">(</span><span class="mi">50</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_pp_array</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_pp_array</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span>
            <span class="c1"># Save ranges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_min</span> <span class="o">=</span> <span class="n">hsl_ns_min</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_max</span> <span class="o">=</span> <span class="n">hsl_ns_max</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;done&#39;</span><span class="p">)</span>  
    
    <span class="k">def</span> <span class="nf">check_hsl_ns_disparity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">is_n_or_s_disparity</span> \
            <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;north&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_north</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_south</span> <span class="k">else</span> <span class="s1">&#39;south&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;HSL mean ± σ(split), σ(all):&#39;</span>
                   <span class="o">+</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">      </span><span class="si">{:2.1f}</span><span class="s1">m&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean</span><span class="p">)</span>
                   <span class="o">+</span><span class="s1">&#39; ± </span><span class="si">{:2.1f}</span><span class="s1">m (split)&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev</span><span class="p">)</span>
                   <span class="o">+</span><span class="s1">&#39; </span><span class="si">{:2.1f}</span><span class="s1">m (all)&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_stddev</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;HSL N-S disparity:&#39;</span>
                   <span class="o">+</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1">      </span><span class="si">{0:2.1f}</span><span class="s1">mN vs </span><span class="si">{1:2.1f}</span><span class="s1">mS   ∆≈</span><span class="si">{2:2.1f}</span><span class="s1">m&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_north</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_mean_south</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;HSL N-S rel disparity vs variation: &#39;</span>
                   <span class="o">+</span><span class="s1">&#39;  </span><span class="si">{0:2.1f}</span><span class="s1">% (</span><span class="si">{1:2.1f}</span><span class="s1">m) NS vs </span><span class="si">{2:2.1f}</span><span class="s1">% (</span><span class="si">{3:2.1f}</span><span class="s1">m)&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_normed</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev_normed</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">hsl_split_stddev</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;HSL N-S disparity signal-noise ratio: ∆/σ = </span><span class="si">{0:2.1f}</span><span class="s1">&#39;</span>
                   <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_confidence</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">*</span><span class="mi">5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_confidence</span><span class="o">&lt;</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s1">&#39;=&gt; very weak </span><span class="si">{}</span><span class="s1"> bias&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">is_n_or_s_disparity</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_confidence</span><span class="o">&lt;</span><span class="mf">1.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s1">&#39;=&gt; weak </span><span class="si">{}</span><span class="s1"> bias&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">is_n_or_s_disparity</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_disparity_confidence</span><span class="o">&lt;</span><span class="mf">2.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s1">&#39;=&gt; moderate </span><span class="si">{}</span><span class="s1"> bias&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">is_n_or_s_disparity</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="n">indent</span><span class="o">+</span><span class="s1">&#39;=&gt; strong </span><span class="si">{}</span><span class="s1"> bias&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">is_n_or_s_disparity</span><span class="p">))</span>  
        
        <span class="c1"># Report classical frequentist tests comparing N and S HSL distributions</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;N-facing vs S-facing HSL distribution comparison tests&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;  for f(HSL_N,S) with N,S bounds 45°&lt;|±aspect|&lt;135° from east&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;D_alpha =  c(alpha)*</span><span class="si">{0:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks_nmfactor</span> <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Kolmogorov-Smirnov: </span><span class="si">{0:0.2f}</span><span class="s1"> p=</span><span class="si">{1:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ks</span> <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Mann-Whitney:       </span><span class="si">{0:0.2f}</span><span class="s1"> p=</span><span class="si">{1:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> 
                                                               <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_mannwhitney</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Rank-sum:           </span><span class="si">{0:0.1f}</span><span class="s1"> p=</span><span class="si">{1:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> 
                                                               <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ranksum</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Student</span><span class="se">\&#39;</span><span class="s1">s t:        </span><span class="si">{0:0.1f}</span><span class="s1"> p=</span><span class="si">{1:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> 
                                                               <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_ttest</span> <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;Welch:              </span><span class="si">{0:0.1f}</span><span class="s1"> p=</span><span class="si">{1:g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> 
                                                               <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_welch</span> <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;P-P:                </span><span class="si">{0:+0.0f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">hsl_ns_pp_diff</span> <span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">(</span><span class="s1">&#39;N-S distribution test statistics not computed&#39;</span><span class="p">)</span>
                                                       
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/../_images/icon3.png" alt="Logo"/>
    
    <h1 class="logo logo-name">Streamlines</h1>
    
  </a>
</p>



<p class="blurb">Topographic streamline mapping of landscape structure</p>







<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <br>
  <p class="biglink"><a class="biglink" href="../py-modindex.html">
         Module Index</a>
  <br><br>
  <h3><a href="../index.html">Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">mapping.py</span></code></a><ul>
<li><a class="reference internal" href="#code">Code</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related</h3>
<ul>
  <li><a href="../index.html"></a><ul>
      <li><a href="analysis.html" title="previous chapter"><code class="docutils literal notranslate"><span class="pre">analysis.py</span></code></a></li>
      <li><a href="plot.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">plot.py</span></code></a></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, CPS.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="../_sources/modules/mapping.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>